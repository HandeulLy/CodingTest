'''
문제 : N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.

입력 : 첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 20, |S| ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.

출력 : 첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.

예시 입력
5 0
-7 -3 -2 5 8
예시 출력
1
'''

# 입력 1 : N(정수, 수열의 개수를 나타냄)과 S(정수, 수열의 원소를 다 더한 값)
# 입력 2 : 정수 N개(빈 칸을 사이에 두고 N개의 정수가 한 줄에 입력)
    # 입력 조건 : N은 1이상 20이하, S는 절대값이 100만이하이다(즉, -1,000,000이상 1,000,000이하이다)
# 목표 : 크기가 양수인 부분수열 중에서 그 수열의 합이 S인 경우의 수를 출력

# "크기가 양수인 부분 수열" : 리스트에서 원소를 1개, 2개, 3개, ... n개씩 뽑아와서 새로운 리스트를 만든다
# "그 수열의 합이 S인" : 새로 만든 리스트의 합이 S인 경우를 찾아야 한다
# "경우의 수를 출력" : count를 증가시키고, 모든 경우의 수를 다 해봐야 한다(이 부분 때문에 브루트포스 관련 문제)

# (그럼에도, 이번에도) 그래도... '덜 무식한' 프로그래밍을 해야 하지 않을까? 그게 이 문제의 핵심이지 않을까?
# 고민해야 할 점
# 1 : 전체 리스트(N개의 정수)에서 x개(1, 2, 3, ..., N)개를 뽑아 올 것인가?
    # 부분 수열의 크기는 양수라고 했으니까 최소 1개부터 시작이라고 할 수 있다
    # 1부터 N까지 풀면 ... 이건 '비효율'로 가는 길이다
    # 1개를 뽑았으면 그 리스트와 짝이 되는 (N-1)개 짜리 리스트가 있다
    # 예를 들어, N=7인 리스트에서는 [1개]-[6개], [2개]-[5개], [3개]-[4개] 그리고 [7개] 이렇게 짝이 지어질 것이다
    # 예를 들어(2), N=6인 리스트에서는 [1개]-[5개], [2개]-[4개], [3개]-[3개] 그리고 [6개] 이렇게 짝이 지어질 것이다
    # 여기서 수행을 절반으로 줄일 수 있다
# 2 : 그럼 x개를 뽑을 때 어떤 방식으로 선택할 것인가?
    # 여기가 문제인데,
    # 1개 2개 정도까지는 어느정도 감당이 되겠지만 3이상이면 반복문으로 풀기는 너무 어려운 (정말 무식한) 방법일 것이다
    # combination? 뭐 어떻게 해야하지? ... 재귀? 
    # 임리 리스트에 원소 하나씩 추가하면서 x개를 뽑을 때까지 재귀를 반복 실행
    # 그럴려면 함수에다가 어떤 인자를 던져줘야하지?
    # x(총 몇개를 뽑아야 하는지), 리스트(저장한거 유지한채로)

N, S = map(int, input().split())
listN = list(map(int, input().split()))
count = 0

def solve(indexPoint, sumValue) :
    global count
    if indexPoint >= N :
        if sumValue == S : count+=1
        return
    print("{} - {} - {}".format(indexPoint, sumValue, count))
    solve(indexPoint+1, sumValue+listN[indexPoint])
    solve(indexPoint+1, sumValue)
    

solve(0, 0)
print(count if S else count-1)
