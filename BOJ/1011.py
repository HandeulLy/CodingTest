# 1011, Fly me to the Alpha Centauri

# 우주선은 이전 작동시기에 k광년을 이동했을 때
# k-1, k, k+1 중 1개의 광년만을 다시 이동할 수 있다

# 예를 들어, 처음 작동시키는 경우 (이론상으로) -1, 0, 1 광년을 이동할 수 있으나
# 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 최초는 1광년 이동이다
# 그 다음에는 0, 1, 2 광년을 이동할 수 있다
# 그리고나서 만약 2 광년만큼 이동한다면 1, 2, 3만큼 이동할 수 있다
# 이 과정을 반복

# 우주선이 x에서 y로 갈 때 최소한의 작동 횟수로 이동하려 한다
# 단, y 도착 직전의 이동거리는 반드시 1 광년으로 한다
# x부터 y로 이동하는 작동 횟수의 최소값을 구하는 프로그램을 작성하라

# 입력 : 첫 줄에 테스트케이스 갯수를 나타내는 T, 그 다음부터는 각 케이스에 대한 x, y의 값
    # x와 y는 정수이며, x가 항상 y보다 작은 값을 갖는다
    # 0 <= x < y < 2^31
# 출력 : 각 케이스에 대한 최소 이동 횟수

#####################################################
#####################################################

# 처음에는 무조건 1만큼 이동, 그리고 많이 이동하려면 직전 이동에 무조건 1 더한 값을 이동하면 될 것이다
# 두번째에는 2, 세번째에는 3, 4 -> 5 ... 이렇게

# 하지만 마냥 커지면 안되는 경우가 있을 것이다
    # x=45, y=50의 경우를 생각하면,
    # 시작-45 / 1-46 / 2-48 / ...
    # 여기서 마지막 직전에는 y-1에 가야하기 때문에 2+1=3이 아니라 2-1=1로 이동해야 함
# 단순히 증가시키면 안된다는 것을 알았다 --- (1)

# 마지막에 1만큼만 이동하려면 그 전 이동 때 몇만큼 이동해야 하는가?
    # 0만큼 움직였으면 -1 0 1 이니까 가능
    # 1만큼 움직였다면 0 1 2 니까 가능
    # 2만큼 이었다면 1 2 3 이니까 가능
# 그러면, (y-x)-1만큼을 최소로 이동할 수 있게 하고, 마지막에 1만큼 한번 더 하면 되겠다 --- (2)

# (1)과 (2)를 종합적으로 생각해보자
# 전체 이동 횟수를 n이라고 했을 때, # 마지막 직전(n-1번 이동 후)에는 (y-x-1)에 있어야 한다
# 그럼 (y-x-1)만큼을 (n-1)번만큼 이동한다(n을 최소한으로)
# n이 최소화 되려면 계속 이동 폭이 커져야 하는데, 마지막에 1만큼 이동하려면 또 줄어야 한다
# 그래서 시작점 x에서부터 (y-x-1)의 절반까지는 증가하고, 그 후부터는 줄어들면서 이동하면 되지 않을까?

# 절반 지점까지 증가하는 부분은 1부터 (y-x)//2까지 증가한다
# 중앙점을 m이라고 할 때, m = (y-x)//2 로 표현할 수 있다

# 그럼 이제 1부터 n까지의 합이 m보다 커지는 순간의 n을 구하면 된다
# 이 부분을 수식으로 계산하기 위해 가우스 공식을 이용했다
            # 수식 넣기

#####################################################

# 아 처음에도 1만큼 이동, 마지막에 1만큼 이동한다
# 그리고 m의 지점까지는 증가하고, 그 이후부터는 감소한다
# 즉, m의 점을 기준으로 대칭의 모습을 보인다

#####################################################
#####################################################

# def sol(x, y) :
#     m = (y-x)//2
#     print("--",m)
#     # for i in range(m+1) : 
#     #     if i*(i+1)/2 > m :
#     #         return i

#     n = [i for i in range(m+1) if i*(i+1)/2 >= m][0]
#     #print(n, 2*n, n*(n+1)/2 + n*(n-1)/2, n*(n+1)/2 + n*(n-1)/2+1 )
#     print(n)
#     print(n*2 if y-x>3 else n*2+1)
#     #print(n*2 if n*2>=m else n*2+1)

#     #print( m*(m+1) + 1)
#     #print(x+m, m)

# # print(sol(0, 3)) # 3
# # print(sol(1, 5)) # 3
# # print(sol(45, 50)) # 4
# # print(sol(0, 10)) # 4

# sol(0, 3) # 3
# sol(1, 5) # 3
# sol(45, 50) # 4
# sol(0, 10) # 4
# sol(1, 17) # 8

#####################################################
#####################################################


# T = int(input())
# for t in range(T) :
#     x, y = map(int, input().split())
#     n = [i for i in range((y-x)//2+1) if i*(i+1)/2 >= (y-x)//2][0]
#     print(n*2 if y-x>3 else n*2+1)

# 메모리 초과
# 이유는 (y-x)에 너무 큰 값이 들어오면 n을 생성할 때 큰 리스트가 되기 때문에


#####################################################
#####################################################


# T = int(input())
# for t in range(T) :
#     x, y = map(int, input().split())
#     for i in range((y-x)//2+1) :
#         if i*(i+1)/2 >= (y-x)//2 :
#             print(i*2 if y-x>3 else i*2+1)
#             break

# 틀렸다, 반례를 찾아보자
# (1, 2) - 1 / 내 코드의 결과 : 1
# (1, 3) - 2 / 내 코드의 결과 : 3
# (1, 4) - 3 / 내 코드의 결과 : 3

# 그냥 코드가 다 틀렸다, 아이디어를 다시 생각해야 함
# 아니야 +1 하는 조건을 조금 더 생각해보자

#####################################################
#####################################################


# 중요한 것은 어느 시점에 "감소하기 시작하는가?"
# 어떤 i 값일 때 감소하기 시작하는지

# def sol(x, y) :
#     #x, y = map(int, input().split())
#     count = 0
#     for i in range((y-x)//2+1) :
#         count += 1
#         if i**2 <= (y-x)//2 :
#             print(x, y, "|", count, i, "|", i*(i+1)/2, (y-x)/2, "|",
#                     (i+1)*2-1 if i*2-1 < (y-x)/2 else i*2)
#             break

# sol(1, 2) # 1
# sol(1, 3) # 2
# sol(1, 4) # 3
# sol(1, 5) # 3
# sol(1, 6) # 4
# sol(1, 7) # 4
# sol(1, 8) # 5
# sol(1, 9) # 5
# sol(1, 10) # 5
# sol(1, 11) # 6
# sol(1, 12) # 6
# sol(1, 13) # 6
# sol(1, 14) # 7
# sol(1, 15) # 7
# sol(1, 16) # 7
# sol(1, 17) # 7
# sol(1, 18) # 7
# sol(1, 19) # 7
# sol(1, 20) # 7

#####################################################

# for t in range(int(input())) :
#     x, y = map(int, input().split())
#     for i in range((y-x)//2+1) :
#         if i*(i+1)/2 >= (y-x)//2 :
#             print(i*2+1 if i*2-1<(y-x)/2 else i*2)
#             break

# 틀렸다, 반례를 찾아보자
# (0, 3) - 3 / 내 코드의 결과 : 3
# (1, 5) - 3 / 내 코드의 결과 : 4
# (45, 50) - 4 / 내 코드의 결과 : 5

#####################################################
#####################################################

for t in range(int(input())) :
    x, y = map(int, input().split())
    count = 1
    while True :
        if count**2 <= y-x < (count+1)**2 : break
        count+=1
    if count**2 == y-x : print(count*2-1)
    elif count**2 < y-x <= count**2+count : print(count*2)
    else : print(count*2+1)