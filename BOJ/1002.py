# 1002 - 터렛

# A좌표 (x1, y1)와 B의 좌표 (x2, y2)가 주어지고,
# 각각의 점에서 C까지의 거리 값(편의상 r1, r2라고 한다)이 주어진다

# 입력 : 첫째 줄에 테스트 케이스의 개수 T가 주어지고, 각 테스트 케이스는 x1, y1, r1, x2, y2, r2로 주어진다
    # x1, y1, x2, y2는 -10,000 이상 10,000이하의 정수
    # r1, r2는 10,000 이하의 자연수
# 출력 : 각 테스트 케이스마다 C가 존재할 수 있는 위치의 수를 출력한다
    # 단, 위치의 개수가 무한대인 경우에는 -1을 출력한다


#####################################################

'''

문제를 이해하면서 원의 방정식이라고 생각했다.
두 원의 방정식이 갖는 해의 개수를 찾아야 하는데, 두 원의 중심과 반지를으로 관계를 찾아야 한다.

먼저, 중심이 같은 경우 반지름의 길이를 기준으로 판단해야 한다.
    1) 반지름이 같으면, 두 원이 같기 때문에 무한대를 갖으므로 문제 조건에 따라 -1을 출력한다.
    2) 반지름이 다르면, 위 [그림 3]의 경우처럼 두 원이 만나는 지점은 없기 때문에 0을 출력한다.

다음으로 중심이 다른 경우, 중심점끼리의 거리 값과 반지름 길이들의 관계를 찾아서 판단해야 한다.
설명하기 쉽게 중심끼리의 거리를 x라고 하고, 반지름 2개를 m과 n으로 하겠다.
    1) x의 값이 m+n과 같은 경우, [그림 2]의 경우처럼 두 원이 한 점에서 만나기 때문에 1을 출력한다.
    2) x의 값이 m+n보다 작은 경우에는 두 원이 만나지 않기 때문에 0을 출력한다.
    3) x의 값이 m+n보다 큰 경우에는 두 원이 [그림 1]의 경우처럼 두 점에서 만나기 때문에 2를 출력한다.

'''

#####################################################
#####################################################

for t in range(int(input())) :
    a, b, m, c, d, n = map(int, input().split())
    x = ( (a-c)**2 + (b-d)**2 ) ** 0.5
    print(x)
    if x == 0.0 :
        if m == n : print(-1)
        else : print(0)
    else : 
        if x == m+n or x == abs(m-n) : print(1)
        elif x > abs(m-n) and x < m+n : print(2)
        else : print(0)