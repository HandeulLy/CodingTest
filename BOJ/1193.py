# 분수 찾기

# 입력 : 1 ~ 10,000,000 사이의 자연수 X
# 출력 : 조건에 맞는 X번째 분수

# 조건
# 무한히 큰 배열에 그림과 같은 규칙으로 분수들이 적혀있다

# 피보나치 계산을 적용하면 되지 않을까?
# 1번 층에는 1개, 2층에는 2개, 3층에는 3개 ...
# 피보나치가 아니고 단순히 1~n까지의 합만 구하면 되네
# 1층부터 n층까지의 개수 합을 구하고 x가 n층과 (n-1)층 사이에 속하는 n을 구하면 된다

# 14가 X로 입력된 예를 생각하면
    # 1 + 2 + 3 + 4  = 10
    # 1 + 2 + 3 + 4  + 5 = 15
# 즉, 4~5층 사이에 14가 속하기 때문에 n은 5가 된다
# 그러면 X에서 (n-1)층 까지의 합을 뺀만큼(이걸 편의상 a라고 해보자) 칸을 이동한다
# 다시 말해, (n-1)층까지는 10번 움직였고, 14 - 10 = 4칸(a)만큼 이동하면 X의 분수 값을 찾을 수 있다
# 여기를 일반화해서 적어보면 분모는 a 분자는 n-a+1의 값을 가질 것이다

# 그럼 n을 찾고, n에 따라서 a를 구해서 값 출력하기

#############################################################
#############################################################

# 내가 제출한 코드(오답)
# 표에서 찾아가는 방향을 반영하지 못함(좌->우 또는 우->좌)
'''
X = int(input())
arr = [1, 2]

while arr[0] < X :
    arr[0], arr[1] = arr[0]+arr[1], arr[1]+1
print('{}/{}'.format(arr[0]+1-X, arr[1]-(arr[0]+1-X)))
'''

#############################################################
#############################################################

# 내가 제출한 코드

X = int(input())
arr = [1, 2]

while arr[0] < X :
    arr[0], arr[1] = arr[0]+arr[1], arr[1]+1
a = arr[0]+1-X
b = arr[1]-a
print('{}/{}'.format(a, b) if arr[1]%2==0 else '{}/{}'.format(b, a))